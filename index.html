<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode Company Questions</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .filters {
            background: #f8f9fa;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        .difficulty-Easy { color: #00b8a3; font-weight: bold; }
        .difficulty-Medium { color: #ffc01e; font-weight: bold; }
        .difficulty-Hard { color: #ff375f; font-weight: bold; }
        .table th { 
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        .table th:hover {
            background-color: #f8f9fa;
        }
        .table th.sorted-asc::after {
            content: " ↑";
        }
        .table th.sorted-desc::after {
            content: " ↓";
        }
        .question-link {
            color: inherit;
            text-decoration: none;
        }
        .question-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1>LeetCode Company Questions</h1>
            <div class="d-flex align-items-center">
                <button class="btn btn-outline-secondary btn-sm me-3" onclick="showSettings()">
                    <i class="bi bi-gear"></i> Settings
                </button>
                <div id="syncStatus" class="me-3" style="display: none; cursor: pointer;" onclick="manualSync()">
                    <span class="badge bg-success">Synced</span>
                    <small class="d-block text-muted" id="lastSyncTime"></small>
                    <small class="d-block text-muted" id="syncDetails"></small>
                </div>
                <button id="googleSignIn" class="btn btn-primary" onclick="signIn()">
                    <i class="bi bi-google"></i> Sign in with Google
                </button>
                <div id="userInfo" style="display: none;" class="ms-3">
                    <img id="userImage" class="rounded-circle me-2" style="width: 32px; height: 32px;">
                    <span id="userName"></span>
                    <button onclick="signOut()" class="btn btn-outline-danger btn-sm ms-2">Sign Out</button>
                </div>
            </div>
        </div>
        
        <div class="filters mb-3">
            <div class="row g-3 align-items-end">
                <div class="col-md-3">
                    <label class="form-label">Select Company</label>
                    <select id="companyFilter" class="form-select">
                        <option value="">Choose a company...</option>
                    </select>
                </div>
                <div id="additionalFilters" style="display: none;">
                    <div class="row g-3 mt-2">
                        <div class="col-md-3">
                            <label class="form-label">Time Period</label>
                            <select id="timeFilter" class="form-select">
                                <option value="">Choose time period...</option>
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Difficulty (Optional)</label>
                            <select id="difficultyFilter" class="form-select">
                                <option value="">All Difficulties</option>
                                <option value="Easy">Easy</option>
                                <option value="Medium">Medium</option>
                                <option value="Hard">Hard</option>
                            </select>
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Search (Optional)</label>
                            <input type="text" id="searchInput" class="form-control" placeholder="Search questions...">
                        </div>
                        <div class="col-md-3">
                            <label class="form-label">Status (Optional)</label>
                            <select id="statusFilter" class="form-select" onchange="filterAndDisplayQuestions()">
                                <option value="">All Questions</option>
                                <option value="completed">Completed</option>
                                <option value="pending">Pending</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="loading" class="loading">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>

        <div id="resultsInfo" class="alert alert-info mb-3" style="display: none;">
            Showing <span id="questionCount">0</span> questions
        </div>

        <div class="table-responsive">
            <table class="table table-striped table-hover">
                <thead class="table-light">
                    <tr>
                        <th class="text-center" style="width: 40px;">✓</th>
                        <th class="text-center" style="width: 50px;">No.</th>
                        <th data-sort="number" class="text-center">ID</th>
                        <th data-sort="title">Title</th>
                        <th data-sort="company">Company</th>
                        <th data-sort="difficulty">Difficulty</th>
                        <th data-sort="acceptance" class="text-end">Acceptance %</th>
                        <th data-sort="frequency" class="text-end">Frequency %</th>
                        <th data-sort="timeframe">Updated</th>
                    </tr>
                </thead>
                <tbody id="questions">
                    <!-- Questions will be dynamically inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const owner = "snehasishroy";
        const repo = "leetcode-companywise-interview-questions";
        const GITHUB_TOKEN_KEY = 'github_access_token';

        // Settings management
        function showSettings() {
            const token = localStorage.getItem(GITHUB_TOKEN_KEY) || '';
            const settingsHtml = `
                <div class="modal" id="settingsModal" tabindex="-1">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Settings</h5>
                                <button type="button" class="btn-close" onclick="closeSettings()"></button>
                            </div>
                            <div class="modal-body">
                                <div class="mb-3">
                                    <label class="form-label">GitHub Personal Access Token</label>
                                    <div class="input-group">
                                        <input type="password" class="form-control" id="githubToken" 
                                               value="${token}" placeholder="Enter token">
                                        <button class="btn btn-outline-secondary" type="button"
                                                onclick="toggleTokenVisibility()">
                                            <i class="bi bi-eye"></i>
                                        </button>
                                    </div>
                                    <div class="form-text">
                                        Create a token with 'repo' scope at 
                                        <a href="https://github.com/settings/tokens" target="_blank">GitHub Settings</a>
                                    </div>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-danger" onclick="clearGitHubToken()">Clear Token</button>
                                <button class="btn btn-primary" onclick="saveSettings()">Save</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to body
            const modalDiv = document.createElement('div');
            modalDiv.innerHTML = settingsHtml;
            document.body.appendChild(modalDiv);

            // Show modal
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'block';
            modal.classList.add('show');
            modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        }

        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.remove('show');
            modal.style.display = 'none';
            modal.remove();
        }

        function toggleTokenVisibility() {
            const input = document.getElementById('githubToken');
            const button = input.nextElementSibling;
            const icon = button.querySelector('i');
            
            if (input.type === 'password') {
                input.type = 'text';
                icon.classList.replace('bi-eye', 'bi-eye-slash');
            } else {
                input.type = 'password';
                icon.classList.replace('bi-eye-slash', 'bi-eye');
            }
        }

        async function saveSettings() {
            const token = document.getElementById('githubToken').value.trim();
            if (token) {
                // Validate token before saving
                try {
                    const response = await fetch('https://api.github.com/user', {
                        headers: { 'Authorization': `token ${token}` }
                    });
                    
                    if (response.ok) {
                        localStorage.setItem(GITHUB_TOKEN_KEY, token);
                        showMessage('Settings saved successfully!', 'success', true);
                        closeSettings();
                        loadCompanies(); // Retry loading with new token
                    } else if (response.status === 401) {
                        showMessage('Invalid GitHub token. Please check and try again.', 'danger');
                    } else {
                        showMessage('Failed to validate GitHub token.', 'danger');
                    }
                } catch (error) {
                    console.error('Error validating token:', error);
                    showMessage('Failed to validate GitHub token.', 'danger');
                }
            }
        }

        function clearGitHubToken() {
            localStorage.removeItem(GITHUB_TOKEN_KEY);
            document.getElementById('githubToken').value = '';
            showMessage('GitHub token cleared', 'info', true);
            closeSettings();
        }

        // GitHub token management
        function setGitHubToken() {
            const token = prompt('Enter your GitHub personal access token:');
            if (token) {
                localStorage.setItem(GITHUB_TOKEN_KEY, token);
                showMessage('GitHub token saved. Retrying...', 'success', true);
                loadCompanies(); // Retry loading with new token
            }
        }

        function getGitHubHeaders() {
            const token = localStorage.getItem(GITHUB_TOKEN_KEY);
            const headers = {
                'Accept': 'application/vnd.github.v3+json'
            };
            if (token) {
                headers['Authorization'] = `token ${token}`;
            }
            return headers;
        }

        // Handle GitHub API errors
        function handleGitHubError(response, showAuthError = true) {
            if (response.status === 401) {
                if (showAuthError) {
                    showMessage(
                        `Invalid GitHub token. Please check your token in settings. 
                         <button class="btn btn-sm btn-primary ms-2" onclick="showSettings()">Open Settings</button>`,
                        'danger'
                    );
                }
                // Clear invalid token
                localStorage.removeItem(GITHUB_TOKEN_KEY);
                return true;
            }
            return false;
        }
        
        // Application state
        const RATE_LIMIT_KEY = 'github_rate_limit_reset';
        let rateLimitRetryTimeout = null;
        
        // Retry after rate limit
        let countdownInterval = null;

        function updateCountdown(endTime) {
            const now = Date.now();
            const remaining = Math.max(0, endTime - now);
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            showMessage(
                `Rate limit exceeded. Retrying in ${minutes}:${seconds.toString().padStart(2, '0')}...
                 <button class="btn btn-sm btn-warning" onclick="cancelRetry()">Cancel</button>`,
                'warning'
            );

            if (remaining <= 0) {
                clearInterval(countdownInterval);
            }
        }

        function scheduleRetry(resetTimeMs) {
            const now = Date.now();
            const delayMs = resetTimeMs - now + 1000; // Add 1 second buffer
            
            if (rateLimitRetryTimeout) {
                clearTimeout(rateLimitRetryTimeout);
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            // Start countdown timer
            updateCountdown(resetTimeMs);
            countdownInterval = setInterval(() => updateCountdown(resetTimeMs), 1000);
            
            rateLimitRetryTimeout = setTimeout(() => {
                localStorage.removeItem(RATE_LIMIT_KEY);
                if (currentFilePath) {
                    fetchCompanyQuestions(currentFilePath);
                } else {
                    loadCompanies();
                }
            }, delayMs);
        }

        function cancelRetry() {
            if (rateLimitRetryTimeout) {
                clearTimeout(rateLimitRetryTimeout);
                rateLimitRetryTimeout = null;
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            showMessage('Retry cancelled. You can try again manually.', 'info', true);
        }
        const questionCache = new Map();
        const companyCache = {
            timestamp: 0,
            data: null,
            expiresIn: 3600000 // 1 hour
        };
        let allQuestions = [];
        let sortColumn = 'number';
        let sortDirection = 'asc';
        let currentFilePath = '';  // Track current selected file
        let currentCompany = '';   // Track current selected company
        
        async function loadCompanies() {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';

            try {
                // Check cache first
                if (companyCache.data && (Date.now() - companyCache.timestamp < companyCache.expiresIn)) {
                    const companyFilter = document.getElementById('companyFilter');
                    companyFilter.innerHTML = '<option value="">Choose a company...</option>';
                    companyCache.data.forEach(company => {
                        const option = document.createElement('option');
                        option.value = company.path;
                        option.textContent = company.name;
                        companyFilter.appendChild(option);
                    });
                    showMessage(`Select a company to view available time periods.`, 'info');
                    loading.style.display = 'none';
                    return;
                }

                console.log('Fetching company list...');
                const repoResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents`, {
                    headers: getGitHubHeaders()
                });
                if (!repoResponse.ok) {
                    if (handleGitHubError(repoResponse)) {
                        return;
                    }
                    if (repoResponse.status === 403) {
                        const resetTime = repoResponse.headers.get('X-RateLimit-Reset');
                        if (resetTime) {
                            localStorage.setItem(RATE_LIMIT_KEY, resetTime * 1000);
                            const waitMinutes = Math.ceil((resetTime * 1000 - Date.now()) / 60000);
                            scheduleRetry(resetTime * 1000);
                            throw new Error(`Rate limit exceeded. Retrying in ${waitMinutes} minutes...`);
                        }
                    }
                    throw new Error('Failed to fetch repository contents');
                }
                
                const contents = await repoResponse.json();
                const companies = contents.filter(item => item.type === 'dir');
                companies.sort((a, b) => a.name.localeCompare(b.name));
                
                // Update cache
                companyCache.data = companies;
                companyCache.timestamp = Date.now();

                const companyFilter = document.getElementById('companyFilter');
                companyFilter.innerHTML = '<option value="">Choose a company...</option>';
                companies.forEach(company => {
                    const option = document.createElement('option');
                    option.value = company.path;
                    option.textContent = company.name;
                    companyFilter.appendChild(option);
                });

                if (companies.length > 0) {
                    showMessage(`Select a company to view available time periods.`, 'info');
                } else {
                    showMessage('No company folders found in the repository.', 'warning');
                }
            } catch (error) {
                console.error('Error loading companies:', error);
                showMessage(error.message, 'danger');
            } finally {
                loading.style.display = 'none';
            }
        }

        async function loadTimeFrames(companyPath) {
            if (!companyPath) {
                document.getElementById('additionalFilters').style.display = 'none';
                allQuestions = [];
                filterAndDisplayQuestions();
                return;
            }

            // Check rate limit
            const rateLimitReset = localStorage.getItem(RATE_LIMIT_KEY);
            if (rateLimitReset) {
                const resetTime = parseInt(rateLimitReset);
                if (Date.now() < resetTime) {
                    const waitMinutes = Math.ceil((resetTime - Date.now()) / 60000);
                    showMessage(`Rate limit exceeded. Please wait ${waitMinutes} minutes.`, 'warning');
                    return;
                }
                localStorage.removeItem(RATE_LIMIT_KEY);
            }

            try {
                const folderResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${companyPath}`, {
                    headers: getGitHubHeaders()
                });
                if (!folderResponse.ok) {
                    if (handleGitHubError(folderResponse)) {
                        return;
                    }
                    if (folderResponse.status === 403) {
                        const resetTime = folderResponse.headers.get('X-RateLimit-Reset');
                        if (resetTime) {
                            localStorage.setItem(RATE_LIMIT_KEY, resetTime * 1000);
                            const waitMinutes = Math.ceil((resetTime * 1000 - Date.now()) / 60000);
                            scheduleRetry(resetTime * 1000);
                            throw new Error(`Rate limit exceeded. Retrying in ${waitMinutes} minutes...`);
                        }
                    }
                    throw new Error(`Failed to fetch company data: ${folderResponse.statusText}`);
                }

                const files = await folderResponse.json();
                const csvFiles = files.filter(file => file.name.endsWith('.csv'));

                // Update timeframe dropdown
                const timeFilter = document.getElementById('timeFilter');
                timeFilter.innerHTML = '<option value="">Choose time period...</option>';
                csvFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.path;
                    option.textContent = file.name.replace('.csv', '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    timeFilter.appendChild(option);
                });

                document.getElementById('additionalFilters').style.display = 'block';

                if (csvFiles.length === 0) {
                    showMessage(`No data files found for ${companyPath.split('/').pop()}`, 'warning');
                }
            } catch (error) {
                showMessage(error.message, 'danger');
            }
        }

        async function fetchCompanyQuestions(filePath) {
            if (!filePath) {
                document.getElementById('resultsInfo').style.display = 'none';
                showMessage('Please select a time period.', 'warning');
                return;
            }

            if (questionCache.has(filePath)) {
                allQuestions = questionCache.get(filePath);
                filterAndDisplayQuestions();
                return;
            }

            const loading = document.getElementById('loading');
            const questionsContainer = document.getElementById('questions');
            loading.style.display = 'block';
            questionsContainer.innerHTML = '';

            // Check rate limit
            const rateLimitReset = localStorage.getItem(RATE_LIMIT_KEY);
            if (rateLimitReset) {
                const resetTime = parseInt(rateLimitReset);
                if (Date.now() < resetTime) {
                    const waitMinutes = Math.ceil((resetTime - Date.now()) / 60000);
                    showMessage(`Rate limit exceeded. Please wait ${waitMinutes} minutes.`, 'warning');
                    loading.style.display = 'none';
                    return;
                }
                localStorage.removeItem(RATE_LIMIT_KEY);
            }

            try {
                const contentResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    headers: {
                        ...getGitHubHeaders(),
                        'Accept': 'application/vnd.github.v3.raw'
                    }
                });
                if (!contentResponse.ok) {
                    if (handleGitHubError(contentResponse)) {
                        return;
                    }
                    if (contentResponse.status === 403) {
                        const resetTime = contentResponse.headers.get('X-RateLimit-Reset');
                        if (resetTime) {
                            localStorage.setItem(RATE_LIMIT_KEY, resetTime * 1000);
                            const waitMinutes = Math.ceil((resetTime * 1000 - Date.now()) / 60000);
                            const tokenExists = localStorage.getItem(GITHUB_TOKEN_KEY);
                            if (!tokenExists) {
                                showMessage(
                                    `Rate limit exceeded. <button class="btn btn-sm btn-primary ms-2" onclick="setGitHubToken()">Add GitHub Token</button>`,
                                    'warning'
                                );
                                return;
                            }
                            scheduleRetry(resetTime * 1000);
                            throw new Error(`Rate limit exceeded. Retrying in ${waitMinutes} minutes...`);
                        }
                    }
                    throw new Error(`Failed to fetch file: ${contentResponse.statusText}`);
                }

                const content = await contentResponse.text();
                currentFilePath = filePath;      // Store the current file path
                currentCompany = filePath.split('/')[0];  // Store company name
                const questions = parseCSVContent(content, currentCompany);

                if (questions.length === 0) {
                    throw new Error(`No questions found in ${filePath}`);
                }

                questionCache.set(filePath, questions);
                allQuestions = questions;
                filterAndDisplayQuestions();
            } catch (error) {
                const errorMessage = error.message;
                showMessage(errorMessage, errorMessage.includes('Rate limit') ? 'warning' : 'danger');
            } finally {
                loading.style.display = 'none';
            }
        }

        function parseCSVContent(content, company) {
            const questions = [];
            // Skip header row and split into lines
            const lines = content.split('\n').slice(1);
            
            for (const line of lines) {
                if (!line.trim()) continue;

                try {
                    // Parse CSV while handling quoted fields
                    const parts = line.match(/(?:^|,)("(?:[^"]|"")*"|[^,]*)/g)
                        .map(part => part.replace(/^,|""/g, ''))
                        .map(part => part.replace(/^"|"$/g, ''))
                        .map(part => part.trim());

                    if (parts.length >= 6) {
                        const number = parts[0].trim();
                        const url = parts[1].trim();
                        const title = parts[2].trim();
                        const difficulty = parts[3].trim();
                        
                        // Parse percentages from CSV
                        const acceptance = parseFloat(parts[4].replace('%', '')) || 0;
                        const frequency = parseFloat(parts[5].replace('%', '')) || 0;

                        if (title && difficulty) {
                            questions.push({
                                number,
                                title,
                                url,
                                difficulty,
                                acceptance,
                                frequency,
                                timeframe: currentFilePath.split('/').pop().replace('.csv', '').replace(/_/g, ' '),
                                company
                            });
                        }
                    }
                } catch (err) {
                    console.warn('Failed to parse CSV line:', line, err);
                }
            }

            return questions;
        }

        function filterAndDisplayQuestions() {
            const searchTerm = document.getElementById('searchInput')?.value?.toLowerCase() || '';
            const difficultyFilter = document.getElementById('difficultyFilter')?.value || '';
            const statusFilter = document.getElementById('statusFilter')?.value || '';

            const filteredQuestions = allQuestions.filter(question => {
                const matchesSearch = searchTerm === '' || question.title.toLowerCase().includes(searchTerm);
                const matchesDifficulty = !difficultyFilter || question.difficulty.toLowerCase() === difficultyFilter.toLowerCase();
                
                // Check completion status
                const isCompleted = localStorage.getItem(`leetcode_solved_${question.number}`) === 'true';
                const matchesStatus = !statusFilter || 
                    (statusFilter === 'completed' && isCompleted) ||
                    (statusFilter === 'pending' && !isCompleted);
                
                return matchesSearch && matchesDifficulty && matchesStatus;
            });

            displayQuestions(filteredQuestions);
        }

        function displayQuestions(questions) {
            const container = document.getElementById('questions');
            const sortedQuestions = sortQuestions(questions);
            
            const count = sortedQuestions.length;
            document.getElementById('questionCount').textContent = count;
            document.getElementById('resultsInfo').style.display = count > 0 ? 'block' : 'none';

            container.innerHTML = sortedQuestions.map((question, index) => `
                <tr class="${localStorage.getItem(`leetcode_solved_${question.number}`) === 'true' ? 'table-success text-muted' : ''}">
                        <td class="text-center">
                            <input type="checkbox" 
                                   class="form-check-input" 
                                   data-question-id="${question.number}"
                                   ${localStorage.getItem(`leetcode_solved_${question.number}`) === 'true' ? 'checked' : ''}
                                   onchange="toggleQuestionStatus(this, '${question.number}')">
                        </td>
                        <td class="text-center">${index + 1}</td>
                    <td class="text-center">${question.number}</td>
                    <td>
                        <a href="${question.url}"
                           target="_blank"
                           class="question-link">
                            ${escapeHtml(question.title)}
                        </a>
                    </td>
                    <td>${question.company}</td>
                    <td><span class="difficulty-${question.difficulty}">${question.difficulty}</span></td>
                    <td class="text-end">${isNaN(question.acceptance) ? 'N/A' : question.acceptance.toFixed(1) + '%'}</td>
                    <td class="text-end">${isNaN(question.frequency) ? 'N/A' : question.frequency.toFixed(1) + '%'}</td>
                    <td>${currentFilePath.split('/').pop().replace('.csv', '').replace(/_/g, ' ')}</td>
                </tr>
            `).join('');

            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.sort === sortColumn) {
                    th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                }
            });
            updateCompletedCount();
        }

        function sortQuestions(questions) {
            return [...questions].sort((a, b) => {
                let aVal = a[sortColumn];
                let bVal = b[sortColumn];
                
                if (['number', 'acceptance', 'frequency', 'timeframe'].includes(sortColumn)) {
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                }
                
                if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });
        }

        function showMessage(message, type = 'danger', autoHide = false) {
            // Add success type styles
            const alertClass = type === 'success' ? 'alert-success' : `alert-${type}`;
            document.getElementById('resultsInfo').style.display = 'none';
            const questionsContainer = document.getElementById('questions');
            questionsContainer.innerHTML = `
                <tr>
                    <td colspan="9">
                        <div class="alert alert-${type} m-0" role="alert">
                            ${message}
                            ${type === 'warning' ? '<br><small class="text-muted">Data will be loaded from cache if available</small>' : ''}
                        </div>
                    </td>
                </tr>
            `;
            
            if (autoHide) {
                setTimeout(() => {
                    questionsContainer.innerHTML = '';
                    document.getElementById('resultsInfo').style.display = 'block';
                }, 5000);
            }
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Event listeners
        document.getElementById('searchInput').addEventListener('input', filterAndDisplayQuestions);
        document.getElementById('companyFilter').addEventListener('change', (e) => loadTimeFrames(e.target.value));
        document.getElementById('timeFilter').addEventListener('change', (e) => fetchCompanyQuestions(e.target.value));
        document.getElementById('difficultyFilter').addEventListener('change', filterAndDisplayQuestions);

        // Column sorting
        document.querySelectorAll('th[data-sort]').forEach(th => {
            th.addEventListener('click', () => {
                const column = th.dataset.sort;
                if (sortColumn === column) {
                    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    sortColumn = column;
                    sortDirection = 'asc';
                }
                filterAndDisplayQuestions();
            });
        });

        // Handle question completion status
        function toggleQuestionStatus(checkbox, questionId) {
            localStorage.setItem(`leetcode_solved_${questionId}`, checkbox.checked);
            updateCompletedCount();
            saveProgressToDrive(); // Auto-save to Drive
            
            // Update row styling
            const row = checkbox.closest('tr');
            if (checkbox.checked) {
                row.classList.add('table-success', 'text-muted');
            } else {
                row.classList.remove('table-success', 'text-muted');
            }
        }

        function updateCompletedCount() {
            const total = allQuestions.length;
            const completed = allQuestions.filter(q => 
                localStorage.getItem(`leetcode_solved_${q.number}`) === 'true'
            ).length;
            
            const countInfo = document.getElementById('questionCount');
            countInfo.innerHTML = `${completed}/${total} completed`;
        }

        // Google Sign-in Integration
        const PROGRESS_FILE_NAME = 'leetcode_progress.json';
        const GOOGLE_TOKEN_KEY = 'google_access_token';
        let accessToken = localStorage.getItem(GOOGLE_TOKEN_KEY);
        let lastSyncTimestamp = null;

        // Auto-restore session
        window.addEventListener('load', async () => {
            if (accessToken) {
                try {
                    // First validate stored token
                    const tokenValidation = await fetch(
                        `https://www.googleapis.com/oauth2/v3/tokeninfo?access_token=${encodeURIComponent(accessToken)}`
                    );
                    
                    if (!tokenValidation.ok) {
                        throw new Error('Invalid stored token');
                    }
                    
                    await getUserInfo();
                    startSyncCheck();
                } catch (error) {
                    console.error('Session restore error:', error);
                    localStorage.removeItem(GOOGLE_TOKEN_KEY);
                    accessToken = null;
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('googleSignIn').style.display = 'block';
                    document.getElementById('syncStatus').style.display = 'none';
                }
            }
        });

        // Initialize or get sync status elements
        function initSyncElements() {
            let syncStatus = document.getElementById('syncStatus');
            if (!syncStatus) {
                syncStatus = document.createElement('div');
                syncStatus.id = 'syncStatus';
                syncStatus.className = 'me-3';
                syncStatus.style.display = 'block';
                syncStatus.style.cursor = 'pointer';
                syncStatus.onclick = manualSync;
                document.querySelector('.d-flex.align-items-center').insertBefore(
                    syncStatus,
                    document.getElementById('googleSignIn')
                );
            }

            let lastSyncTime = document.getElementById('lastSyncTime');
            let syncDetails = document.getElementById('syncDetails');
            
            if (!lastSyncTime || !syncDetails) {
                syncStatus.innerHTML = `
                    <span class="badge bg-warning">Syncing</span>
                    <small class="d-block text-muted" id="lastSyncTime">Initializing...</small>
                    <small class="d-block text-muted" id="syncDetails">Preparing sync...</small>
                `;
                lastSyncTime = document.getElementById('lastSyncTime');
                syncDetails = document.getElementById('syncDetails');
            }

            return { syncStatus, lastSyncTime, syncDetails };
        }

        // Check sync status
        async function checkSyncStatus() {
            if (!accessToken) return;

            try {
                const driveResponse = await fetch(
                    `https://www.googleapis.com/drive/v3/files?q=name='${PROGRESS_FILE_NAME}'&spaces=drive&fields=files(id,modifiedTime)`,
                    {
                        headers: { Authorization: `Bearer ${accessToken}` }
                    }
                );
                const driveData = await driveResponse.json();

                const { syncStatus, lastSyncTime, syncDetails } = initSyncElements();

                if (driveData.files.length > 0) {
                    const file = driveData.files[0];
                    const modifiedTime = new Date(file.modifiedTime);
                    const localTime = lastSyncTimestamp ? new Date(lastSyncTimestamp) : null;

                    if (!localTime || modifiedTime > localTime) {
                        syncStatus.innerHTML = '<span class="badge bg-warning">Update Available</span>';
                        lastSyncTime.textContent = 'Remote changes detected';
                        syncDetails.textContent = 'Click to sync changes';
                        return false;
                    } else {
                        syncStatus.innerHTML = '<span class="badge bg-success">Synced</span>';
                        lastSyncTime.textContent = `Last synced: ${localTime.toLocaleTimeString()}`;
                        syncDetails.textContent = 'Click to sync manually';
                        return true;
                    }
                }
                return true;
            } catch (error) {
                console.error('Error checking sync status:', error);
                return false;
            }
        }

        // Start periodic sync check
        function startSyncCheck() {
            if (accessToken) {
                checkSyncStatus();
                setInterval(checkSyncStatus, 60000); // Check every minute
                
                // Add online/offline event listeners
                window.addEventListener('online', () => {
                    const syncDetails = document.getElementById('syncDetails');
                    syncDetails.textContent = 'Reconnected, syncing...';
                    manualSync();
                });
                
                window.addEventListener('offline', () => {
                    const syncStatus = document.getElementById('syncStatus');
                    const syncDetails = document.getElementById('syncDetails');
                    syncStatus.innerHTML = '<span class="badge bg-warning">Offline</span>';
                    syncDetails.textContent = 'Waiting for connection...';
                });
            }
        }

        function signIn() {
            const client = google.accounts.oauth2.initTokenClient({
                client_id: '500272341880-1ouid9flni5uu8nfn05phmefeush77na.apps.googleusercontent.com',
                scope: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.profile',
                callback: async (response) => {
                    try {
                        if (response.access_token) {
                            accessToken = response.access_token;
                            localStorage.setItem(GOOGLE_TOKEN_KEY, accessToken);
                            
                            // Validate token immediately
                            const tokenValidation = await fetch(
                                `https://www.googleapis.com/oauth2/v3/tokeninfo?access_token=${encodeURIComponent(accessToken)}`
                            );
                            
                            if (!tokenValidation.ok) {
                                throw new Error('Invalid token received');
                            }
                            
                            const tokenInfo = await tokenValidation.json();
                            if (!tokenInfo.scope || !tokenInfo.scope.includes('drive.file')) {
                                throw new Error('Insufficient permissions');
                            }
                            
                            await getUserInfo();
                            startSyncCheck();
                        }
                    } catch (error) {
                        console.error('Sign in error:', error);
                        localStorage.removeItem(GOOGLE_TOKEN_KEY);
                        accessToken = null;
                        showMessage('Failed to sign in. Please try again.', 'danger');
                    }
                },
                error_callback: (error) => {
                    console.error('OAuth error:', error);
                    showMessage('Failed to initialize Google Sign-In.', 'danger');
                }
            });
            try {
                client.requestAccessToken();
            } catch (error) {
                console.error('Token request error:', error);
                showMessage('Failed to start sign in process.', 'danger');
            }
        }

        async function getUserInfo() {
            if (!accessToken) {
                throw new Error('No access token available');
            }

            try {
                // First validate the token
                const tokenValidation = await fetch(
                    `https://oauth2.googleapis.com/tokeninfo?access_token=${encodeURIComponent(accessToken)}`
                );

                const tokenInfo = await tokenValidation.json();
                if (!tokenValidation.ok || !tokenInfo.scope) {
                    localStorage.removeItem(GOOGLE_TOKEN_KEY);
                    accessToken = null;
                    throw new Error('Invalid or expired token');
                }

                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                    headers: { 
                        'Authorization': `Bearer ${accessToken}`,
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    method: 'GET'
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        localStorage.removeItem(GOOGLE_TOKEN_KEY);
                        accessToken = null;
                        throw new Error('Authentication failed - please sign in again');
                    }
                    throw new Error(`Failed to fetch user info: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Ensure all required elements exist before updating UI
                const userInfo = document.getElementById('userInfo');
                const googleSignIn = document.getElementById('googleSignIn');
                const userImage = document.getElementById('userImage');
                const userName = document.getElementById('userName');
                const syncStatus = document.getElementById('syncStatus');
                
                if (!userInfo || !googleSignIn || !userImage || !userName || !syncStatus) {
                    throw new Error('Required UI elements not found');
                }
                
                userInfo.style.display = 'flex';
                googleSignIn.style.display = 'none';
                userImage.src = data.picture;
                userName.textContent = data.name;
                syncStatus.style.display = 'block';
                
                localStorage.setItem('googleUserId', data.sub);
                
                // Initialize sync status if needed
                const syncDetails = document.getElementById('syncDetails');
                if (!syncDetails) {
                    syncStatus.innerHTML = `
                        <span class="badge bg-warning">Initializing</span>
                        <small class="d-block text-muted" id="lastSyncTime"></small>
                        <small class="d-block text-muted" id="syncDetails">Preparing sync...</small>
                    `;
                }
                
                await loadProgressFromDrive();
            } catch (error) {
                console.error('Error fetching user info:', error);
                // Clear invalid token state
                localStorage.removeItem(GOOGLE_TOKEN_KEY);
                accessToken = null;
                
                // Reset UI state
                const userInfo = document.getElementById('userInfo');
                const googleSignIn = document.getElementById('googleSignIn');
                const syncStatus = document.getElementById('syncStatus');
                
                if (userInfo) userInfo.style.display = 'none';
                if (googleSignIn) googleSignIn.style.display = 'block';
                if (syncStatus) syncStatus.style.display = 'none';
                
                // Show error message
                showMessage('Session expired. Please sign in again.', 'warning');
                throw error;
            }
        }

        // Manual sync trigger
        async function manualSync() {
            if (!accessToken) {
                showMessage('Please sign in to sync progress', 'warning');
                return;
            }

            const { syncStatus, lastSyncTime, syncDetails } = initSyncElements();
            
            try {
                syncStatus.style.pointerEvents = 'none';
                syncDetails.textContent = 'Syncing...';
                
                if (!navigator.onLine) {
                    syncStatus.innerHTML = '<span class="badge bg-warning">Offline</span>';
                    syncDetails.textContent = 'Waiting for connection...';
                    return;
                }
                
                await saveProgressToDrive();
                await loadProgressFromDrive();
                
                syncStatus.style.pointerEvents = 'auto';
                syncDetails.textContent = 'Click to sync manually';
            } catch (error) {
                console.error('Sync error:', error);
                if (syncStatus && syncDetails) {
                    syncStatus.innerHTML = '<span class="badge bg-danger">Sync Failed</span>';
                    syncDetails.textContent = 'Error during sync';
                }
            }
        }

        // Save progress to Google Drive
        async function saveProgressToDrive() {
            if (!accessToken) return;

            const progressData = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('leetcode_solved_')) {
                    progressData[key] = localStorage.getItem(key);
                }
            }

            const fileMetadata = {
                name: PROGRESS_FILE_NAME,
                mimeType: 'application/json'
            };

            const file = new Blob([JSON.stringify(progressData)], {type: 'application/json'});
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(fileMetadata)], {type: 'application/json'}));
            form.append('file', file);

            try {
                const searchResponse = await fetch(
                    `https://www.googleapis.com/drive/v3/files?q=name='${PROGRESS_FILE_NAME}'&spaces=drive&fields=files(id)`,
                    {
                        headers: { Authorization: `Bearer ${accessToken}` }
                    }
                );
                const searchResult = await searchResponse.json();

                if (searchResult.files.length > 0) {
                    // Update existing file
                    const fileId = searchResult.files[0].id;
                    await fetch(
                        `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`,
                        {
                            method: 'PATCH',
                            headers: { Authorization: `Bearer ${accessToken}` },
                            body: form
                        }
                    );
                } else {
                    // Create new file
                    await fetch(
                        'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
                        {
                            method: 'POST',
                            headers: { Authorization: `Bearer ${accessToken}` },
                            body: form
                        }
                    );
                }
                // Update sync status
                lastSyncTimestamp = new Date().toISOString();
                const syncStatus = document.getElementById('syncStatus');
                syncStatus.style.display = 'block';
                syncStatus.innerHTML = '<span class="badge bg-success">Synced</span>';
                document.getElementById('lastSyncTime').textContent = `Last synced: ${new Date().toLocaleTimeString()}`;
                document.getElementById('syncDetails').textContent = 'Click to sync manually';
            } catch (error) {
                console.error('Error saving to Drive:', error);
                const syncStatus = document.getElementById('syncStatus');
                syncStatus.style.display = 'block';
                if (error.message.includes('401')) {
                    // Handle expired token
                    localStorage.removeItem(GOOGLE_TOKEN_KEY);
                    accessToken = null;
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('googleSignIn').style.display = 'block';
                    showMessage('Session expired. Please sign in again.', 'warning');
                } else {
                    syncStatus.innerHTML = '<span class="badge bg-danger">Sync Failed</span>';
                    const syncDetails = document.getElementById('syncDetails');
                    syncDetails.textContent = 'Error saving progress';
                    setTimeout(() => {
                        syncStatus.innerHTML = '<span class="badge bg-warning">Sync Error</span>';
                        syncDetails.textContent = 'Click to retry sync';
                    }, 3000);
                }
            }
        }

        // Load progress from Google Drive
        async function loadProgressFromDrive() {
            if (!accessToken) {
                console.log('No access token available for sync');
                return;
            }
            
            const syncStatus = document.getElementById('syncStatus');
            const syncDetails = document.getElementById('syncDetails');
            
            syncDetails.textContent = 'Loading progress...';
            syncStatus.style.display = 'block';

            if (!navigator.onLine) {
                syncStatus.innerHTML = '<span class="badge bg-warning">Offline</span>';
                syncDetails.textContent = 'Waiting for connection...';
                return;
            }
            try {
                const searchResponse = await fetch(
                    `https://www.googleapis.com/drive/v3/files?q=name='${PROGRESS_FILE_NAME}'&spaces=drive&fields=files(id)`,
                    {
                        headers: { Authorization: `Bearer ${accessToken}` }
                    }
                );
                const searchResult = await searchResponse.json();

                if (searchResult.files.length > 0) {
                    const fileId = searchResult.files[0].id;
                    const result = await fetch(
                        `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
                        {
                            headers: { Authorization: `Bearer ${accessToken}` }
                        }
                    );
                    const progressData = await result.json();
                    Object.entries(progressData).forEach(([key, value]) => {
                        localStorage.setItem(key, value);
                    });
                    document.getElementById('syncStatus').style.display = 'block';
                    lastSyncTimestamp = new Date().toISOString();
                    document.getElementById('syncStatus').innerHTML = '<span class="badge bg-success">Synced</span>';
                    document.getElementById('lastSyncTime').textContent = `Last synced: ${new Date().toLocaleTimeString()}`;
                    filterAndDisplayQuestions(); // Refresh display
                }
            } catch (error) {
                console.error('Error loading from Drive:', error);
                if (error.message.includes('401')) {
                    // Handle expired token
                    localStorage.removeItem(GOOGLE_TOKEN_KEY);
                    accessToken = null;
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('googleSignIn').style.display = 'block';
                    showMessage('Session expired. Please sign in again.', 'warning');
                } else {
                    syncStatus.innerHTML = '<span class="badge bg-danger">Sync Failed</span>';
                    syncDetails.textContent = 'Error loading progress';
                    setTimeout(() => {
                        syncStatus.innerHTML = '<span class="badge bg-warning">Sync Error</span>';
                        syncDetails.textContent = 'Click to retry sync';
                    }, 3000);
                }
            }
        }

        // Google Sign-in functions
        function onSignIn(googleUser) {
            const profile = googleUser.getBasicProfile();
            document.getElementById('userInfo').style.display = 'flex';
            document.getElementById('googleSignIn').style.display = 'none';
            document.getElementById('userImage').src = profile.getImageUrl();
            document.getElementById('userName').textContent = profile.getName();
            
            // Save user ID for data syncing
            localStorage.setItem('googleUserId', profile.getId());
            loadProgressFromDrive();
            startSyncCheck(); // Start periodic sync checks
        }

        function signOut() {
            // Get current token before clearing
            const currentToken = accessToken;
            
            // Clear tokens and user data
            accessToken = null;
            localStorage.removeItem(GOOGLE_TOKEN_KEY);
            localStorage.removeItem('googleUserId');
            
            // Update UI
            document.getElementById('userInfo').style.display = 'none';
            document.getElementById('googleSignIn').style.display = 'block';
            document.getElementById('syncStatus').style.display = 'none';
            
            // Revoke Google access if we have a token
            if (currentToken) {
                fetch('https://oauth2.googleapis.com/revoke?token=' + currentToken, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                }).catch(err => console.error('Error revoking token:', err));
                
                google.accounts.oauth2.revoke(currentToken, () => {
                    console.log('Token revoked');
                });
            }
            
            showMessage('Signed out successfully', 'info', true);
        }

        // Initialize and load companies
        loadCompanies();
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
